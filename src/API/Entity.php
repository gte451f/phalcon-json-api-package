<?php

namespace PhalconRest\API;

use Phalcon\Di;
use Phalcon\DI\Injectable;
use Phalcon\Mvc\Model\Relation as PhalconRelation;
use PhalconRest\Exception\HTTPException;
use PhalconRest\Exception\ValidationException;
use PhalconRest\Result\Result;


/**
 * Pulls together one or more models to represent the REST resource(s)
 * Early work revolves around supporting API calls like...Model w/ Related Records
 * Loosely follows the Phalcon Model api...that is when entity performs a function
 * similar to a model, it attempts to mimic the function name and signatures
 */
class Entity extends Injectable
{

    /**
     * store a list of all active relationships
     * not just a list of all possible relationships
     *
     * @var PhalconRelation[]|Relation[]
     */
    public $activeRelations = null;

    /**
     * store the intermediate format of the rest response
     *
     * @var Result
     **/
    public $result;

    /**
     * keep a copy of the entity records PKID
     *
     * @var int
     */
    public $primaryKeyValue = null;

    /**
     * temporary value used to store the currently loaded database record
     * can be accessed from around the entity class
     *
     * @var \PhalconRest\Result\Data
     */
    protected $baseRecord = null;

    /**
     * store Phalcon lib for use throughout the class
     *
     * @var \Phalcon\Mvc\Model\MetaData\Memory
     *
     */
    protected $metaData;

    /**
     * a searchHelper object used for when queries originate from HTTP requests
     *
     * @var SearchHelper
     */
    public $searchHelper = null;

    /**
     * store the total records found in a search (before limit)
     *
     * @var integer
     */
    private $recordCount = null;

    /**
     * relevant only for save function
     *
     * @var string insert | update
     */
    protected $saveMode = null;

    /**
     * the model that drives the entity
     *
     * @var BaseModel
     */
    protected $model;

    /**
     * store the query builder object used by the entity to pull data from the database
     *
     * @var QueryBuilder
     */
    private $queryBuilder;


    /**
     * hold a list of all related records that are to be fetched from the database and
     * related to their parent record
     *
     * takes the form of [ReferenceModelNameSpace'=>[various, requested, foreign_keys];
     * @var array
     */
    private $hasManyRegistry = [];

    /**
     * @see $hasManyRegistry
     * used to store a registry of records related through hasManyToMany relationships
     *
     * @var array
     */
    public $hasManyToManyRegistry = [];

    /**
     * this is a bit of a hack, but we need a safe way to smuggle the parent id of a has_many_through back upstream
     * when processing these requests through delayed means
     *
     * consider enhancing the hasManyToManyRegistry to store this?
     */
    const SECRETPARENTNAME = 'aksdjflwejfoijd';


    /**
     * process injected model
     *
     * @param BaseModel $model
     * @param SearchHelper $searchHelper
     * @throws HTTPException
     */
    function __construct(BaseModel $model, SearchHelper $searchHelper)
    {
        $di = Di::getDefault();
        $this->setDI($di);

        // the primary model associated with with entity
        $this->model = $model;

        // hook to configure entity determined searchHelper defaults
        // a searchHelper, needed anytime we load an entity
        $this->searchHelper = $this->configureSearchHelper($searchHelper);

        // the final result generated by the entity object
        $this->result = $di->get('result', [$model->getTableName()]);

        // load since it is nearly always needed
        $this->loadActiveRelationships();
    }

    /**
     * Where soeme API rules are enforced
     * may also be extended to directly manipulate the searchHelper
     *
     * @param SearchHelper $searchHelper
     * @return SearchHelper
     */
    public function configureSearchHelper(SearchHelper $searchHelper): SearchHelper
    {
        //load rules and apply to this entity in read situations...if it's a read situation
        $modelRuleStore = $this->di->get('ruleList')->get($this->model->getModelName());
        // apply rules logic if any are configured
        if ($modelRuleStore) {
            foreach ($modelRuleStore->getRules(READRULES, 'FilterRule') as $rule) {
                // include operator if it is anything other than equals
                $searchHelper->entitySearchFields[$rule->field] = ($rule->operator == '=') ? $rule->value : $rule->operator . $rule->value;
                // support for related table filters
                if ($rule->parentTable) {
                    $searchHelper->addEntityWith($rule->parentTable);
                }
            }
        }
        return $searchHelper;
    }

    /**
     * For a given search query, performs a find + loading of related records
     *
     * @return mixed|Result
     * @throws HTTPException
     */
    public function find()
    {
        // tell the result object what type of result to generate
        $this->result->outputMode = 'multiple';

        $baseRecords = $this->runSearch();

        $foundSet = 0;
        if ($this->di->get('config')['application']['debugApp'] == true) {
            $timer = $this->di->get('stopwatch');
            $timer->lap('Gather Records');
        }

        foreach ($baseRecords as $baseResult) {
            // normalize results, pull out join fields and store in a class lvl variable
            $this->makeBaseRecord($this->extractMainRow($baseResult));

            // process relations if there are any
            if (count($this->activeRelations) > 0) {
                // hook for manipulating the base record before processing relationships
                $baseResult = $this->beforeProcessRelationships($baseResult);

                // store related records in restResponse or load for optimized DB queries
                $this->processRelationships($baseResult);

                // hook for manipulating the base record after processing relationships
                $this->afterProcessRelationships($baseResult);
            }
            // finally add the data object to result, last chance to manipulate this object
            $this->result->addData($this->baseRecord);
            $foundSet++;
        }

        // no need to process if no primary records are found
        if ($foundSet > 0) {
            // pull in related records that are to be processed as separate & batched queries
            // processing hasMany is one good example
            $this->processDelayedRelationships();
        }

        if (isset($timer)) {
            $timer->lap('Formatting Output');
        }
        // TODO single DB query for records related to main query
        $this->appendMeta($foundSet);
        return $this->result;
    }

    /**
     * process all the SQL requests queued up while processing records but delayed
     */
    public function processDelayedRelationships()
    {
        foreach ($this->activeRelations as $relation) {
            $refType = $relation->getType();
            if ($refType == PhalconRelation::HAS_MANY) {
                // finally process a combined call for child records
                $this->getHasManyRecords($relation);
            }
            // let's try to support delayed has_many_through to cut down on the number of DB queries we have to run
            if ($refType == PhalconRelation::HAS_MANY_THROUGH) {
                // process a combined call for child records
                $this->getHasManyToManyRecords($relation, false);
            }
        }
    }

    /**
     * hook for manipulating the base record before processing relationships
     * this method is called from the find and findFirst methods
     *
     * @param mixed $baseResult
     * @return mixed $baseResult
     */
    public function beforeProcessRelationships($baseResult)
    {
        return $baseResult;
    }

    /**
     * hook for manipulating the base record after processing relatoinships.
     * this method is called from the find and findFirst methods
     *
     * will accept baseResult as param but there is no point in passing it back up since the real data is in a class level object
     *
     * @param mixed $baseResult
     */
    public function afterProcessRelationships($baseResult)
    {
    }

    /**
     * for a given ID, load a record including any related tables
     * such as employee+user, user addresses and user phones
     *
     * @param mixed $id The PKID for the record
     * @return mixed|Result
     * @throws HTTPException
     */
    public function findFirst($id)
    {
        // farm this part out since it might be used elsewhere in the entity
        $baseRecords = $this->partialFindFirst($id);

        // if we don't find a record, terminate with an empty result set
        if ($baseRecords === false) {
            return $this->result;
        }

        $foundSet = 0;
        if ($this->di->get('config')['application']['debugApp'] == true) {
            $timer = $this->di->get('stopwatch');
            $timer->lap('Gathering Records');
        }
        foreach ($baseRecords as $baseResult) {
            // normalize results, pull out join fields and store in a class lvl variable
            $this->makeBaseRecord($this->extractMainRow($baseResult));

            // hook for manipulating the base record before processing relationships
            $baseResult = $this->beforeProcessRelationships($baseResult);

            // store related records in restResponse or load for optimized DB queries
            $this->processRelationships($baseResult);

            // hook for manipulating the base record after processing relationships
            $this->afterProcessRelationships($baseResult);

            $this->result->addData($this->baseRecord);
            $foundSet++;
        }

        // no need to process if no primary records are found
        if ($foundSet > 0) {
            // pull in related records that are to be processed as separate & batched queries
            $this->processDelayedRelationships();
        }
        if (isset($timer)) {
            $timer->lap('Formatting Output');
        }

        $this->appendMeta($foundSet);
        return $this->result;
    }

    /**
     * break up job to find a particular record for easier reuse
     *
     * @param $id
     * @return mixed
     */
    protected function partialFindFirst($id)
    {
        // store for future reference
        $this->primaryKeyValue = $id;
        // tell the result object what type of result to generate
        $this->result->outputMode = 'single';

        // prep for a special kind of search
        $this->searchHelper->entityLimit = 1;
        $searchField = $this->model->getPrimaryKeyName();
        $this->searchHelper->entitySearchFields[$searchField] = $id;

        // this is Business Rules aware
        $result = $this->runSearch();

        // attempt to smooth return types
        if ($result === false) {
            return false;
        }
        if (getType($result) == 'array' and count($result) == 0) {
            return false;
        }

        return $result;
    }

    /**
     * add a few extra metrics as enabled by the system
     *
     * @param int $foundSet a count of the records matching api request
     */
    protected function appendMeta($foundSet)
    {
        // should we load pager information?
        if ($this->searchHelper->isPager) {

            // calculate the number of "paged" records in total
            $this->result->addMeta('total_pages', ceil($this->recordCount / $this->searchHelper->getLimit()));
            $this->result->addMeta('total_record_count', $this->recordCount);
            $this->result->addMeta('returned_record_count', $foundSet);

            $config = $this->getDI()->get('config');
            if ($config['application']['debugApp']) {
                $registry = $this->getDI()->get('registry');
                if (isset($registry->dbCount)) {
                    $this->result->addMeta('database_query_count', $registry->dbCount);
                }
                if (isset($registry->dbTimer)) {
                    $this->result->addMeta('database_query_timer', $registry->dbTimer . ' ms');
                }
            }
        }
    }

    /**
     * coordinating action that performs a search based on underlying query builder
     *
     * @return mixed
     */
    public function runSearch()
    {
        // hook before query in case entity needs to act
        $this->beforeQueryBuilderHook();

        $queryBuilder = $this->di->get('queryBuilder', [$this->model, $this->searchHelper, $this]);

        // run this once for the count
        $query = $queryBuilder->build('count');

        //load rules and apply to this entity in read situations
        $modelRuleStore = $this->di->get('ruleList')->get($this->model->getModelName());
        // apply rules logic if any are configured
        if ($modelRuleStore) {
            foreach ($modelRuleStore->getRules(READRULES, 'QueryRule') as $rule) {
                $query->andWhere($rule->clause);
            }
        }

        // access hook after queryBuilder in case entity needs to act on the query
        $query = $this->afterQueryBuilderHook($query);

        $result = $query->getQuery()->getSingleResult();
        $this->recordCount = intval($result->count);

        if (!$this->searchHelper->isCount && $this->recordCount) {
            // now run the real query with the same hooks
            $this->beforeQueryBuilderHook();
            $query = $queryBuilder->build();
            $query = $this->afterQueryBuilderHook($query);
            // $sql = $query->getQuery();
            return $query->getQuery()->execute();
        } else {
            return [];
        }
    }


    /**
     * for a given base record, build an array to represent a single row including merged tables
     * strip out extra merge rows and return a single result record
     *
     * @param BaseModel|\Phalcon\Mvc\Model\Row|BaseModel[] $baseRecord
     * @return void
     */
    public function extractMainRow($baseRecord): array
    {
        // basically check for parent records and pull them out
        if ($baseRecord instanceof \Phalcon\Mvc\Model\Row) {
            // hold the combined and normalized array of data fields
            $baseArray = [];
            $primaryModel = $this->model->getModelNameSpace();

            foreach ($baseRecord as $record) {
                $class = get_class($record);
                $modelName = $record->getModelName('plural');
                if ($primaryModel === $class) {
                    $primaryArray = $this->loadAllowedColumns($record, false, false);
                    continue;
                }
                foreach ($this->activeRelations as $relation) {
                    $refType = $relation->getType();
                    $relationName = $relation->getModelName('plural');
                    if ($refType == PhalconRelation::HAS_ONE AND $relationName == $modelName) {
                        // if a valid related record is found, merge it in
                        // ie, if the related record is missing if FK, then skip it
                        $relatedField = $relation->getReferencedFields();
                        if ($record->$relatedField > 0) {
                            $baseArray = array_merge($this->loadAllowedColumns($record, false, false), $baseArray);
                        }
                    }
                }
            }
            // put this step in to make sure that primary fields always appear before related fields
            $baseArray = array_merge($baseArray, $primaryArray ?? []);
        } else {
            $baseArray = $this->loadAllowedColumns($baseRecord, false, false);
        }

        return $baseArray;
    }

    /**
     * for a supplied baseArray, create a data record for the entity to use
     *
     * @param $baseArray
     */
    public function makeBaseRecord($baseArray)
    {
        $primaryKeyId = $this->model->getPrimaryKeyName();

        $this->baseRecord = $this->di->get('data',
            [$baseArray[$primaryKeyId], $this->model->getTableName('plural'), $baseArray]);
    }

    /**
     * For a given record, load any related values. Runs inside {@link find()} and {@link findFirst()}.
     *
     * @see processCustomRelationships()
     * @see processStandardRelationships()
     * @see $baseRecord
     * @param \Phalcon\Mvc\Model\Row|BaseModel[] $baseRecord the base record to decorate
     * @return bool Results are put together on {@link $baseRecord}
     * @throws HTTPException
     */
    public function processRelationships($baseRecord)
    {
        // load primaryKeyValue
        $this->primaryKeyValue = $this->baseRecord->getId();

        // process all loaded relationships by fetching related data
        foreach ($this->activeRelations as $relation) {
            // check if this relationship has been flagged for custom processing
            $relationOptions = $relation->getOptions();
            if (isset($relationOptions) && (array_key_exists('customProcessing',
                        $relationOptions) && ($relationOptions['customProcessing'] === true))
            ) {
                $this->processCustomRelationships($relation, $baseRecord);
            } else {
                $this->processStandardRelationships($relation, $baseRecord);
            }
        }
        return true;
    }

    /**
     * This method is stubbed out here so that it can be extended and used in local Entity file
     * to do custom processing for certain endpoints
     *
     * @param PhalconRelation|Relation $relation
     * @param \Phalcon\Mvc\Model\Row|BaseModel[] $baseRecord
     * @return boolean
     */
    protected function processCustomRelationships($relation, $baseRecord)
    {
        return true;
    }

    /**
     * Standard method for processing relationships
     * build an intermediate list of related records
     * 1) add them to the current data records
     * 2) normalize them for inclusion in the final response
     *
     * @param PhalconRelation|Relation $relation
     * @param \Phalcon\Mvc\Model\Row|BaseModel[] $baseRecord
     * @throws HTTPException
     * @return mixed
     * @fixme this method contains some odd return points
     */
    protected function processStandardRelationships($relation, $baseRecord)
    {
        // store parentModels for later use
        $parentModels = $this->model->getParentModels(true);

        if ($parentModels and in_array($relation->getReferencedModel(), $parentModels)) {
            // skip any parent relationships because they are merged into the main record
        } else {
            $alias = $relation->getAlias();
            // figure out if we have a preferred alias
            if (isset($alias)) {
                $refModelName = $alias;
            } else {
                $refModelName = $relation->getModelName();
            }

            // harmonize relatedRecords
            switch ($relation->getType()) {
                case PhalconRelation::BELONGS_TO:
                    // for simple belongsTo, pluck the related record out of base record since we know its in there
                    // some belongsTo have parent records, revert to the older style to get a complete record
                    if ($relation->getParent()) {
                        $this->getBelongsToRecord($relation, $baseRecord);
                    } else {
                        $this->loadRelationRecords([$baseRecord->$refModelName], $relation);
                    }
                    break;
                case PhalconRelation::HAS_ONE:
                    // ignore hasOne since they are processed like a parent relation
                    // this means current logic will not merge in a parent's record for a hasOne relationship
                    // it's an edge case but should be supported in the future
                    break;
                case PhalconRelation::HAS_MANY_THROUGH:
                    // $this->getHasManyToManyRecords($relation, true);
                    // register a future record request to be processed later
                    $this->registerHasManyToManyRequest($relation);
                    break;

                case PhalconRelation::HAS_MANY:
                    // register a future record request to be processed later
                    $this->registerHasManyRequest($relation);

                    break;

                default:
                    // wah!
                    throw new HTTPException('Unknown relationship submitted', 500, ['code' => '4984846846849494']);
            }
            return true;
        }
    }

    /**
     * hook for an entity to act before queryBuilder runs
     * no query object supplied since this occurs before one yet exists
     *
     * @return void
     */
    public function beforeQueryBuilderHook()
    {

    }

    /**
     * hook to allow for custom work to be done on the $query object before returning it
     *
     * @param $query
     * @return mixed
     */
    public function afterQueryBuilderHook($query)
    {
        return $query;
    }

    /**
     * Normalize the related records so they can be added into the response object
     *
     * @param \Phalcon\Mvc\Model\Row|BaseModel[] $baseRecord
     * @param array $relatedRecords
     * @param PhalconRelation|Relation $relation
     * @return boolean
     */
    protected function normalizeRelatedRecords($baseRecord, $relatedRecords, $relation)
    {
        $refType = $relation->getType();

        $refModelNameSpace = $relation->getReferencedModel();

        /** @var BaseModel $refModel */
        // store a copy of all related record (PKIDs)
        // this must be attached w/ the parent records for joining purposes
        $relatedRecordIds = null;
        $refModel = new $refModelNameSpace();
        $primaryKeyName = $refModel->getPrimaryKeyName();

        // save the PKID for each record returned
        if (count($relatedRecords) > 0) {
            switch ($refType) {
                // process hasOne records as well
                case PhalconRelation::HAS_ONE:
                    // do nothing w/ hasOne since these are auto merged into the main record
                    break;
                case PhalconRelation::BELONGS_TO:
                    // this doesn't seem right, why are they occasionally showing up inside an array?
                    if (isset($relatedRecords[$primaryKeyName])) {
                        $relatedRecordIds = $relatedRecords[$primaryKeyName];
                        // wrap in array so we can store multiple hasOnes from many different main records
                        $relatedRecords = [$relatedRecords];
                    } else {
                        $relatedRecordIds = $relatedRecords[0][$primaryKeyName];
                    }
                    break;

                default:
                    $relatedRecordIds = [];
                    foreach ($relatedRecords as $rec) {
                        $relatedRecordIds[] = $rec[$primaryKeyName];
                    }
                    break;
            }
        } else {
            $relatedRecordIds = null;
        }

        // we map table names to end point resource names and vice versa
        // regardless of relationship, the related records are returned as part of the end point resource name
        $this->updateRestResponse($relation->getTableName(), $relatedRecords);

        // add related record ids to the baseArray
        // this is how JSON API suggests that you related resources
        // will save nothing, a single value or an array

        // does this only run when working with hasMany?
        // belongsTo and hasOne are already in place, yes?
        if ($relatedRecordIds !== null) {
            if ($refType == PhalconRelation::HAS_MANY || $refType == PhalconRelation::HAS_MANY_THROUGH) {
                // populate the linked property or merge in additional records
                // attempt to store the name similar to the table name
                $name = $relation->getTableName('singular') . '_ids';
                $this->baseRecord[$name] = $relatedRecordIds;
            }
        }

        return true;
    }

    /**
     * load an array of records into the restResponse
     *
     * @param string $table the table name where the records originated
     * @param array $records usually related records, but could side load just about any records to an api response
     * @param bool $skipDuplicateCheck should this run ignore the duplicate check?
     * @return void
     */
    protected function updateRestResponse($table, array $records, $skipDuplicateCheck = false)
    {
        foreach ($records as $record) {
            $this->result->addIncluded($this->di->get('data', [$record['id'], $table, $record]));
        }
    }

    /**
     * push a single record into the rest response
     * check for duplicates
     *
     * @param string $table the table name where the records originated
     * @param array $newRecord usually related records, but could side load just about any records to an api response
     * @param boolean $skipDuplicateCheck should the function skip checking for duplicates and push it into the rest response directly?
     *  this can be useful when you know the chance of duplicates is close to zero
     * @return void
     */
    protected function pushRestResponse($table, array $newRecord, $skipDuplicateCheck = false)
    {
        if (!isset($this->restResponse[$table])) {
            $this->restResponse[$table][] = $newRecord;
        } else {
            if ($skipDuplicateCheck == false) {
                // check that this array doesn't already exist, otherwise push it into the stack
                foreach ($this->restResponse[$table] as $record) {
                    // if the number of keys differ...it's different
                    if (count($record) === count($newRecord)) {
                        // try two different ways to compare records when checking for duplicates
                        $match = true;
                        foreach (array_keys($newRecord) as $key) {
                            if ($newRecord[$key] !== $record[$key]) {
                                $match = false;
                            }
                        }
                        // all keys match, bug out!
                        if ($match) {
                            return;
                        }

                        // this appears to be slower
                        // if (serialize($newRecord) === serialize($record)) {
                        // return;
                        // }
                    }
                }
            }
            $this->restResponse[$table][] = $newRecord;
        }
    }


    /**
     * extract only approved fields from a resultset
     * this works with each resultset's model to get a list of allowed columns
     * hence the similar method signature
     *
     * @param BaseModel $resultSet
     * @param bool $nameSpace
     * @param bool $includeParent
     * @return array
     */
    protected function loadAllowedColumns(BaseModel $resultSet, $nameSpace = true, $includeParent = true)
    {
        $record = [];
        $allowedFields = $resultSet->getAllowedColumns($nameSpace, $includeParent);
        foreach ($allowedFields as $field) {
            if (isset($resultSet->$field)) {
                $record[$field] = $resultSet->$field;
            } else {
                $getter = 'get' . ucfirst($field);
                if (method_exists($resultSet, $getter)) {
                    $record[$field] = $resultSet->$getter();
                } else {
                    // error, field doesn't exist on resultSet!
                    // don't set to null, just leave it alone
                    $record[$field] = null;
                }
            }
        }
        return $record;
    }

    /**
     * built for hasMany relationships
     * in cases where the related record itself refers to a parent record,
     * write a custom query to load the related record including it's parent
     *
     * depends on the existence of a primaryKeyValue
     *
     * @param Relation|PhalconRelation $relation
     * @param bool Should the entity auto-merge hasOne records for the model in this relationship?
     * @return array
     */
    protected function getHasManyRecords(Relation $relation, bool $includeHasOnes = true)
    {
        $query = $this->buildRelationQuery($relation, $includeHasOnes);

        // feature flag is enable, pulling from register instead
        $foreign_keys = array_unique($this->hasManyRegistry[$relation->getReferencedModel()]);
        $query->inWhere($relation->getReferencedFields(), $foreign_keys);

        $result = $query->getQuery()->execute();
        return $this->loadRelationRecords($result, $relation, false);
    }

    /**
     * store away a request for a record in a child table
     * this registry is later processed to side load found records
     * @param Relation|PhalconRelation $relation
     */
    protected function registerHasManyRequest(Relation $relation)
    {
        // determine the key to search against
        $field = $relation->getFields();
        if (isset($this->baseRecord->attributes[$field])) {
            $fieldValue = $this->baseRecord->attributes[$field];
        } else {
            // fall back to using the primaryKeyValue
            $fieldValue = $this->primaryKeyValue;
        }
        $this->hasManyRegistry[$relation->getReferencedModel()][] = $fieldValue;
    }

    /**
     * store away a request for a record in a child table
     * this registry is later processed in processDelayedRelationships to side load found records
     * @param Relation|PhalconRelation $relation
     */
    protected function registerHasManyToManyRequest(Relation $relation)
    {
        // determine the key to search against
        $field = $relation->getFields();
        if (isset($this->baseRecord->attributes[$field])) {
            $fieldValue = $this->baseRecord->attributes[$field];
        } else {
            // fall back to using the primaryKeyValue
            $fieldValue = $this->primaryKeyValue;
        }
        $this->hasManyToManyRegistry[$relation->getReferencedModel()][] = $fieldValue;
    }

    /**
     * built for belongsTo relationships
     * in cases where the related record itself refers to a parent record,
     * write a custom query to load the related record including it's parent (and has ones?)
     *
     * @param PhalconRelation|Relation $relation
     * @param $baseRecord - expect this to be a complex result, otherwise why would you be here gathering belongsTo?
     * @return array
     * @throws HTTPException
     */
    private function getBelongsToRecord(Relation $relation, $baseRecord)
    {
        $query = $this->buildRelationQuery($relation);
        $referencedField = $relation->getReferencedFields();
        $foreignKey = $relation->getFields();

        // can take a shortcut here,
        // check to see if this record has already been loaded
        $tableName = $relation->getTableName();
        $modelName = $relation->getModelName();
        $aliasName = $relation->getAlias();
        $foreignKeyValue = $baseRecord->$aliasName->$referencedField;
        $existingRecord = $this->result->getInclude($tableName, $foreignKeyValue);

        // since this record has already been loaded, we only need to link to current record
        //...or maybe not if it's already connected
        if ($existingRecord) {
            $this->baseRecord->addRelationship($relation->getTableName('singular'), $existingRecord->getId(),
                $tableName);
        } else {
            // query uses model prefix to avoid ambiguous queries
            $query->where("{$relation->getReferencedModel()}.{$referencedField} = \"{$this->baseRecord->getFieldValue($foreignKey)}\"");
            $result = $query->getQuery()->execute();
            return $this->loadRelationRecords($result, $relation);
        }
    }

    /**
     * load the query object for a hasManyToMany relationship
     * build most of the joins manually since by reference relationship in the model isn't working so well
     * this support joins to distant tables with parent models
     *
     * @param PhalconRelation|Relation $relation
     * @param bool $before
     * @return array
     * @throws HTTPException
     */
    public function getHasManyToManyRecords($relation, $before = true)
    {
        $field = $relation->getFields();
        $intermediateModelNameSpace = $relation->getIntermediateModel();

        $query = $this->buildHasManyToManyQuery($relation);
        $fieldValue = $this->baseRecord->getFieldValue($field);

        if ($before) {
            $whereField = $intermediateModelNameSpace . '.' . $relation->getIntermediateFields();
            $query->where("{$whereField} = \"$fieldValue\"");
        } else {
            // Here is the change to the original getHasManyToMany to use inWhere
            $whereField = $intermediateModelNameSpace . '.' . $relation->getIntermediateFields();
            $foreign_keys = array_unique($this->hasManyToManyRegistry[$relation->getReferencedModel()]);
            $query->inWhere($whereField, $foreign_keys);
        }

        $result = $query->getQuery()->execute();
        return $this->loadRelationRecords($result, $relation, $before);
    }


    /**
     * a helper function to build part of a hasManyToMany query
     * split out to make this accessible to decedent entities
     *
     * @param $relation
     * @return \Phalcon\Mvc\Model\Query\Builder
     */
    final public function buildHasManyToManyQuery($relation)
    {
        $refModelNameSpace = $relation->getReferencedModel();
        $intermediateModelNameSpace = $relation->getIntermediateModel();

        // determine the key to search against
        $referencedField = $relation->getReferencedFields();
        $intermediateFields = $relation->getIntermediateReferencedFields();

        $config = $this->getDI()->get('config');
        $modelNameSpace = $config['namespaces']['models'];
        $mm = $this->getDI()->get('modelsManager');

        /** @var \Phalcon\Mvc\Model\Query\Builder $query */
        $query = $mm->createBuilder()
            ->from($intermediateModelNameSpace)
            ->join($refModelNameSpace,
                $refModelNameSpace . ".$referencedField = " . $intermediateModelNameSpace . ".$intermediateFields");

        // run the query through the relationship in case additional filters are supplied
        $query = $this->processRelationshipFilters($query, $relation);

        $columns = [];

        // join in parent record if one is detected
        $parentName = $relation->getParent();
        if ($parentName) {
            /** @var BaseModel $parentModel */
            // load parent model
            /** @var BaseModel $parentModel */
            $parentModelNameSpace = $modelNameSpace . $parentName;
            $parentModel = new $refModelNameSpace();
            // load reference relationship
            $parentRelationship = $parentModel->getRelation($parentName);

            $columns[] = "$parentModelNameSpace.*";
            $query->join($parentModelNameSpace,
                "$parentModelNameSpace." . $parentRelationship->getReferencedFields() . " = $refModelNameSpace." . $parentRelationship->getFields(),
                $parentModelNameSpace);
        }

        // Load the main record field at the end, so they are not overwritten
        $columns[] = $refModelNameSpace . ".*, " . $intermediateModelNameSpace . ".*";
        $query->columns($columns);

        return $query;
    }


    /**
     * for a given relation, apply filters to the supplied query
     *
     *
     * @param \Phalcon\Mvc\Model\Query\Builder $query
     * @param Relation $relation
     * @return \Phalcon\Mvc\Model\Query\Builder
     */
    protected function processRelationshipFilters(
        \Phalcon\Mvc\Model\Query\Builder $query,
        \PhalconRest\API\Relation $relation
    )
    {

        // check for additional filters that should be included, only process an array of filters
        $relationOptions = $relation->getOptions();
        if (array_key_exists('filters', $relationOptions)) {
            // make supplied filters an array regardless of what it was fed
            if (!is_array($relationOptions['filters'])) {
                $filters = [$relationOptions['filters']];
            } else {
                $filters = $relationOptions['filters'];
            }

            // loop through each and build a where clause
            foreach ($filters as $filter) {
                $randomName = 'rand' . rand(1, 1000000);
                $query->andWhere("$filter->name $filter->operator :$randomName:", [
                    $randomName => $filter->value
                ]);
            }
        }

        return $query;
    }


    /**
     * utility shared between getBelongsToRecord and getHasManyRecords
     *
     * @param PhalconRelation|Relation $relation
     * @param bool Should the entity auto-merge hasOne records for the model in this relationship?
     * @return object
     */
    protected function buildRelationQuery(Relation $relation, bool $includeHasOnes = true)
    {
        /** @var \Phalcon\Mvc\Model\Query\Builder $query */
        $refModelNameSpace = $relation->getReferencedModel();
        $mm = $this->getDI()->get('modelsManager');
        $query = $mm->createBuilder()->from($refModelNameSpace);
        $columns = [];

        // run the query through the relationship in case additional filters are supplied
        $query = $this->processRelationshipFilters($query, $relation);

        // enforce rules logic?
        $query = $this->processRelationRules($query, $relation);

        // hasOnes are auto merged if requested
        if ($includeHasOnes) {
            // todo should this be controlled by entityWith?
            $list = $relation->getHasOnes();
            foreach ($list as $model) {
                $columns[] = $model . '.*';
                $query->leftJoin($model);
            }
        }

        // Load the main record field at the end, so they are not overwritten
        $columns[] = $refModelNameSpace . ".*";
        $query->columns($columns);

        return $query;
    }

    /**
     *
     * @param $query
     * @param $relation
     * @return mixed
     */
    protected function processRelationRules($query, \PhalconRest\API\Relation $relation)
    {
        $relatedModel = $relation->getModel();
        $modelRuleStore = $this->di->get('ruleList')->get($relatedModel->getModelname());

        // process all filter rules
	// disable since it breaks some side loaded calls
        //foreach ($modelRuleStore->getRules(READRULES, 'FilterRule') as $rule) {
        //    $queryField = new \PhalconRest\Query\QueryField($rule->field, $rule->operator . $rule->value, $relatedModel);
        //    if ($queryField->isValid() === true) {
        //        $query = $queryField->addWhereClause($query);
        //    }
        //}

        //load rules and apply to this query for related records
        foreach ($modelRuleStore->getRules(READRULES, 'QueryRule') as $rule) {
            $query->andWhere($rule->clause);
        }
        return $query;
    }

    /**
     * utility shared between getBelongsToRecord and getHasManyRecords
     * will process a related record result and then update the result and current baseRecord objects
     *
     * @param array $relatedRecords - simple array of records that should be loaded into the final result set
     * @param PhalconRelation|Relation $relation
     * @param boolean $before is this being run before or after all baseRecords were loaded?
     * @throws HTTPException
     */
    protected function loadRelationRecords($relatedRecords, Relation $relation, $before = true)
    {
        $relatedPrimaryKey = $relation->getPrimaryKeyName();

        foreach ($relatedRecords as $relatedRecord) {
            // leverage helper function to extract the complete related record as an array
            $relatedRecArray = $this->getRelatedRecord($relatedRecord, $relation);

            // if record appears to be invalid, skip
            if (!$relatedRecArray) {
                continue;
            }

            if ($relation->getAlias()) {
                $relationshipName = $relation->getAlias();
            } else if ($relation->getType() == PhalconRelation::BELONGS_TO) {
                $relationshipName = $relation->getTableName('singular');
            } else {
                $relationshipName = $relation->getTableName('plural');
            }

            if ($before) {
                $this->baseRecord->addRelationship($relationshipName, $relatedRecArray['id'],
                    $relation->getTableName('plural'));
            } else {
                // load relationship after baseRecords have been processed
                if ($relation->getType() == PhalconRelation::HAS_MANY_THROUGH) {
                    // we expect this to be present based on work done in getRelatedRecord()
                    $parentId = $relatedRecArray[self::SECRETPARENTNAME];
                    // the intent here is to clean up extra fields that are only used processing has_many_through via
                    // the delayed approach and the api should not present in the response
                    unset($relatedRecArray[self::SECRETPARENTNAME]);
                } else {
                    $parentId = $relatedRecArray[$relation->getReferencedFields()];
                }
                $this->result->addRelationship($parentId, $relationshipName,
                    $relatedRecArray[$relatedPrimaryKey], $relation->getTableName('plural'));
            }
            $newInclude = $this->di->get('data',
                [$relatedRecArray[$relatedPrimaryKey], $relation->getTableName('plural'), $relatedRecArray]);

            $this->result->addIncluded($newInclude);
        }
    }


    /**
     * a small function that when given a relatedRecord and the relation
     * will extract the complete record as an array
     *
     * @param BaseModel $relatedRecord
     * @param PhalconRelation|Relation $relation
     * @return array|boolean
     */
    protected function getRelatedRecord($relatedRecord, Relation $relation)
    {
        // reset for each run
        $relatedRecArray = [];
        // when a related record contains hasOne or a parent, merge in those fields as part of side load response
        $parent = $relation->getParent();
        $classType = get_class($relatedRecord);
        if (($parent AND $classType == 'Phalcon\Mvc\Model\Row') or $classType == 'Phalcon\Mvc\Model\Row') {
            // process records that include joined in parent records
            foreach ($relatedRecord as $rec) {
                // filter manyHasMany differently than other relationships
                if ($relation->getType() == PhalconRelation::HAS_MANY_THROUGH) {
                    // while we normally are only interested in the "end" relationship, not the intermediate
                    // we need the parent_id in order to join this record to the parent
                    $intermediateModelNameSpace = $relation->getIntermediateModel();
                    if ($intermediateModelNameSpace == get_class($rec)) {
                        // let's smuggle in the intermediate "parent id" or left side id
                        // we'll clean this out in the upstream function
                        // it's the best way I know to provide this value back while avoiding extra DB calls
                        $intermediateField = $relation->getIntermediateFields();
                        $intermediateValue = $rec->$intermediateField;
                        $relatedRecArray[self::SECRETPARENTNAME] = $intermediateValue;
                        continue;
                    }
                }
                // we don't ask for parent fields here because they are already included in the complex $result
                $currentRec = $this->loadAllowedColumns($rec, false, false);
                $relatedRecArray = array_merge_if_not_null($currentRec, $relatedRecArray);
            }
        } else {
            // reset for each run
            $relatedRecArray = false;
            // let's inspect this for basic validity and ignore out empty records
            // think of a join on optional table
            $primaryKeyName = $relatedRecord->getPrimaryKeyName();
            if (isset($relatedRecord->$primaryKeyName) AND $relatedRecord->$primaryKeyName != null) {
                $relatedRecArray = $this->loadAllowedColumns($relatedRecord, false, false);
            }
        }
        return $relatedRecArray;
    }




    /**
     * for a given set of relationships,
     * load them into the entity so find* functions return all requested related data
     *
     * make this a getter? It doesn't actually return the array, so keeping as load
     *
     * always load parent model(s)
     *
     * auto = do nothing
     * all = load all possible relationships
     * csv,list = load only these relationships
     *
     * @return bool|void
     * @throws HTTPException
     */
    final public function loadActiveRelationships()
    {
        // no need to run this multiple times
        if (!is_null($this->activeRelations)) {
            return null;
        }

        $this->activeRelations = [];
        $requestedRelationships = $this->searchHelper->getWith();
        $parentModels = $this->model->getParentModels(false);
        $modelRelationships = $this->model->getRelations();

        $all = false; // load all relationships?

        // process the private array of relationships
        switch ($requestedRelationships) {
            case 'none':
                $all = false;
                // gotta load parents if there are any
                $requestedRelationships = $parentModels ? $parentModels : [];
                break;
            case 'all':
                $all = true;
                break;
            // expect & process a csv string
            default:
                // expect csv list or simple string
                // user_addrs,user_phones
                $requestedRelationships = array_filter(explode(',', strtolower($requestedRelationships)));
                // include parents if there are any
                if ($parentModels) {
                    $requestedRelationships = array_merge($parentModels, $requestedRelationships);
                }
                break;
        }

        //FIXME: there's a lot of repeated code here. Simplify this!
        if ($all) {
            // load all defined relationships regardless of what was requested
            foreach ($modelRelationships as $relation) {
                $modelName = $relation->getModelName();
                $aliasName = $relation->getAlias();

                //register in result object as well
                $this->result->registerRelationshipDefinitions($relation);

                // figure out if we have a preferred alias
                if ($aliasName) {
                    $this->activeRelations[$aliasName] = $relation;
                } else {
                    $this->activeRelations[$modelName] = $relation;
                }
            }
        } else {
            //
            foreach ($requestedRelationships as $requestedRelationship) {
                $matchFound = false;
                foreach ($modelRelationships as $relation) {
                    $modelName = $relation->getModelName();
                    $aliasName = $relation->getAlias();

                    $this->result->registerRelationshipDefinitions($relation);

                    // make sure the relationship is approved either as the table name, model name or ALL
                    // table names because end point resources = table names
                    // model name because some auto generated relationships use this name instead
                    // alias is used to STORE the active relationship in case multiple relationships point to the same model
                    // but it is not a valid way for a client to request data
                    if ($requestedRelationship == $aliasName) {
                        $matchFound = true;
                        // figure out if we have a preferred alias
                        if ($aliasName) {
                            $this->activeRelations[$aliasName] = $relation;
                        } else {
                            $this->activeRelations[$modelName] = $relation;
                        }
                        break;
                    }
                }

                if (!$matchFound) {
                    foreach ($modelRelationships as $relation) {
                        $tableName = $relation->getTableName();
                        $modelName = $relation->getModelName();
                        $aliasName = $relation->getAlias();

                        //register in result object as well
                        $this->result->registerRelationshipDefinitions($relation);

                        if ($requestedRelationship == $tableName) {
                            $matchFound = true;
                            // figure out if we have a preferred alias
                            if ($aliasName) {
                                $this->activeRelations[$aliasName] = $relation;
                            } else {
                                $this->activeRelations[$modelName] = $relation;
                            }
                            break;
                        }
                    }
                } else {
                    continue;
                }

                if (!$matchFound) {
                    // if you are still here, then you have a problem!
                    // a relation ship was requested that doesn't actually exist
                }
            }
        }

        $this->afterloadActiveRelationships();

        return true;
    }

    /**
     * hook to be called after loading active relationships
     *
     * @return bool
     */
    protected function afterLoadActiveRelationships()
    {
        return true;
    }

    /**
     * remove a complete entity based on a supplied primary key
     * TODO how to handle deleting from a leaf node, check this->parentModel
     * currently this logic depends on the SQL cascade rule to do the heavy lifting
     *
     * @param int $id
     * @throws HTTPException
     * @return boolean
     */
    public function delete($id)
    {
        // test that this record can be found in the API
        // if it isn't found, return a not found, not access denied
        $modelRuleStore = $this->di->get('ruleList')->get($this->model->getModelName());

        // if we don't find a record, terminate with an empty result set
        if ($this->partialFindFirst($id) === false) {
            // no record found to delete
            throw new HTTPException("Could not find record #$id to delete.", 404, [
                'dev' => "No record was found to delete",
                'code' => '564648616899764'
            ]);
        }

        $primaryModelName = $this->model->getModelNameSpace();
        $modelToDelete = $primaryModelName::findFirst($id);

        if ($modelToDelete != false) {
            if ($modelRuleStore) {
                foreach ($modelRuleStore->getRules(DELETERULES, 'ModelCallbackRule') as $rule) {
                    $rule->evaluateCallback($modelToDelete, null);
                }
            }

            $this->beforeDelete($modelToDelete);

            // attempt delete run gold leader!
            if ($modelToDelete->delete() == false) {
                // store error messages
                $messageBag = $this->getDI()->get('messageBag');
                foreach ($this->model->getMessages() as $message) {
                    $messageBag->set($message->getMessage());
                }
                throw new HTTPException("Error deleting record #$id.", 500, ['code' => '66498419846816']);
            }
        } else {
            // no record found to delete
            throw new HTTPException("Could not find record #$id to delete.", 404, [
                'dev' => "No record was found to delete",
                'code' => '2343467699'
            ]);
        }
        $this->afterDelete($modelToDelete);
        return true;
    }

    /**
     * hook to be run before an entity is deleted
     * make it easier to extend default delete logic
     *
     * @param BaseModel $model the record to be deleted
     */
    public function beforeDelete(BaseModel $model)
    {
        // extend me in child class
    }

    /**
     * hook to be run after an entity is deleted
     * make it easier to extend default delete logic
     *
     * @param mixed $model the record that was just removed
     */
    public function afterDelete($model)
    {
        // extend me in child class
    }

    /**
     * hook to be run before an entity is saved make it easier to extend default save logic
     *
     * @param object $object the data submitted to the server
     * @param int|null $id the pkid of the record to be updated, otherwise null on inserts
     * @return BaseModel $object
     */
    public function beforeSave($object, $id = null)
    {
        // extend me in child class
        return $object;
    }

    /**
     * hook to be run after an entity is saved
     * make it easier to extend default save logic
     *
     * @param mixed $object the data submitted to the server
     * @param int|null $id the pkid of the record to be updated or inserted
     */
    public function afterSave($object, $id)
    {
        // extend me in child class
    }

    /**
     * hook to be run after an entity is saved
     * and relationships have been processed
     *
     * @param mixed $object the data submitted to the server
     * @param int|null $id the pkid of the record to be updated or inserted
     */
    public function afterSaveRelations($object, $id)
    {
        // extend me in child class
    }

    /**
     * attempt to add/update a new entity
     * watch $id to determine if update or insert
     * built to accommodate saving records w/ parent tables (hasOne)
     *
     * @param array|object $formData the data submitted to the server
     * @param int $id the pkid of the record to be updated, otherwise null on inserts
     * @return int the PKID of the record in question
     * @throws HTTPException
     */
    public function save($formData, $id = null)
    {
        if (!is_object($formData)) {
            $formData = (object)$formData;
        }

        // load rulestore for further use
        $modelRuleStore = $this->di->get('ruleList')->get($this->model->getModelName());

        // check if inserting a new record and account for any parent records
        if (is_null($id)) {
            $this->saveMode = 'insert';
            // pre-save hook placed after saveMode
            $formData = $this->beforeSave($formData, $id);

            //need to create a new model since this is an insert
            $modelNameSpace = $this->model->getModelNameSpace();
            $this->model = new $modelNameSpace($this->di);

            // apply rules logic if any are configured
            if ($modelRuleStore) {
                // now run through modelCallback
                foreach ($modelRuleStore->getRules(CREATERULES, 'ModelCallbackRule') as $rule) {
                    $rule->evaluateCallback($this->model, $formData);
                }
            }


            // load a model including potential parents
            $primaryModel = $this->loadParentModel($this->model, $formData);
        } else {
            // update existing record
            $this->saveMode = 'update';

            // pre-save hook placed after saveMode
            $formData = $this->beforeSave($formData, $id);

            // make sure that the PKID is always stored in the formData
            $keyName = $this->model->getPrimaryKeyName();
            $formData->$keyName = $id;

            $this->primaryKeyValue = $id;


            // this step supports business rules of type FILTER and QUERY designed to restrict access to this record
            if ($this->partialFindFirst($id) === false) {
                // no record found to delete
                throw new HTTPException("Could not find record #$id to $this->saveMode.", 404, [
                    'dev' => "No record was found to delete",
                    'code' => '94948646813138891981'
                ]);
            }

            // need parent logic here
            $this->model = ($this->model)::findFirst($id);
            if (!$this->model) {
                throw new HTTPException("Could not find record #$id to update.", 404, [
                    'dev' => "No record was found to update",
                    'code' => '293542512610127'
                ]);
            }

            // apply rules logic if any are configured
            if ($modelRuleStore) {
                // run this operation through modelCallback and denyIf
                foreach ($modelRuleStore->getRules(UPDATERULES, 'DenyIfRule') as $rule) {
                    // if true, that means deny
                    $result = $rule->evaluateRule($this->model->{$rule->field});
                    if ($rule->evaluateRule($this->model->{$rule->field})) {
                        throw new HTTPException("Could not edit record", 404, [
                            'dev' => "Failed rule check.",
                            'code' => '4684941864684684684'
                        ]);
                    }
                }

                // now run through modelCallback
                foreach ($modelRuleStore->getRules(UPDATERULES, 'ModelCallbackRule') as $rule) {
                    $rule->evaluateCallback($this->model, $formData);
                }
            }


            $primaryModel = $this->loadParentModel($this->model, $formData);

            // // TODO this only works with 1 parent so far....
            // $parentModelName = $model::$parentModel;
            // if ($parentModelName) {
            // $config = $this->getDI()->get('config');
            // $modelNameSpace = $config['namespaces']['models'];
            // $parentNameSpace = $modelNameSpace . $parentModelName;
            // $parentModel = $parentNameSpace::findFirst($id);
            // $primaryModel = $this->loadModelValues($parentModel, $formData);
            // }
        }

        // no need to pass in formData since it was already loaded in $this->loadParentModel
        $result = $primaryModel->save();

        // if still blank, pull from recently created $result
        if (is_null($id)) {
            $this->primaryKeyValue = $id = $result;
        }

        // post save hook that is called before relationships have been saved
        $this->afterSave($formData, $id);

        // post save hook that is called after all relations have been saved as well
        $this->afterSaveRelations($formData, $id);

        $this->saveMode = null; // revert since save is finished
        return $this->primaryKeyValue;
    }

    /**
     * for a given model, load the parent if it exists
     * return the final definitive parent model,
     * along with loading client submitted data into each model
     *
     * @param BaseModel $model
     * @param object $formData
     * @return bool|object $model
     */
    public function loadParentModel(BaseModel $model, $formData)
    {
        // invalid first param, return false though it won't do much good
        if ($model === false) {
            return false; //FIXME: when will this happen? sounds like a workaround?
        }

        if ($model::$parentModel != false) {
            /** @var BaseModel $parentModel */
            $config = $this->getDI()->get('config');
            $modelNameSpace = $config['namespaces']['models'];
            $parentNameSpace = $modelNameSpace . $model::$parentModel;
            $parentModel = new $parentNameSpace();

            if ($this->saveMode == 'update') {
                $primaryKey = $model->getPrimaryKeyName();
                $finalModel = $parentModel::findFirst($model->$primaryKey);
            } else {
                $finalModel = $this->loadParentModel($parentModel, $formData);
            }

            // don't forget to load the child model values and mount into parent model
            $childModel = $this->loadModelValues($model, $formData);
            $childModelName = $model->getModelName();
            $finalModel->$childModelName = $childModel;
        } else {
            $finalModel = $model;
        }

        // run object data through the model
        return $this->loadModelValues($finalModel, $formData);
    }

    /**
     * load object data into the current model
     * only include specific known fields
     * will also include block fields since it expects there to be blocked at the controller
     *
     * @param BaseModel $model
     * @param object $formData
     *
     * @return BaseModel a model loaded with all relevant data from the object
     */
    public function loadModelValues($model, $formData)
    {
        // loop through nearly all known fields and save matches
        $metaData = $this->getDI()->get('memory');
        // use a colMap to prepare for save
        $colMap = $metaData->getColumnMap($model);
        if (is_null($colMap)) {
            // but if it isn't present, fall back to attributes
            $colMap = $metaData->getAttributes($model);
        }

        foreach ($colMap as $key => $label) {
            if (property_exists($formData, $label)) {
                // odd because $key shows up on model while $label doesn't
                // but $label WORKS and $key doesn't
                // must be some magic method property stuff
                $model->$label = $formData->$label;
            }
        }

        return $model;
    }

    /**
     * Simple alias for {@link BaseModel::save()}.
     * Used to do more stuff that now happens inside the model. Replace with <code>$model->save()</code>.
     * @deprecated
     * @param BaseModel $model
     * @throws ValidationException
     * @return int|false
     */
    function simpleSave($model)
    {
        return $model->save();
    }
}
